{"pages":[],"posts":[{"title":"Hello World","text":"马上就是新的一年，准备拾到拾到，整理下这一年的收获。","link":"/2019/12/29/hello-world/"},{"title":"函数进阶：理解函数调用","text":"4.1隐式函数参数（arguments）arguments与Array arguments对象仅是一个类数组的结构，在使用中尤为注意，避免把arguments参数当做_数组_。 12// 将arguments转换成数组Array.prototype.slice.call(arguments) 严格模式与非严格模式的使用区别 在非严格模式下 arguments可以作为函数参数的别名，严格模式则无法使用，建议避免使用别名影响代码的可读性。 4.2 函数4中调用方式4.2.1作为一个函数（function）——— skulk() ,直接被调用1234567// 函数声明function skulk(){}// 函数表达式const samurai = function(){}// 如何区别： 以function 开头的为函数声明 注：以这种方式调用时，函数上下文（this）有两种可能 在非严格模式下，它将是全局上下文（window对象） 在严格模式下，它将是undefined 4.2.2作为一个方法（method）—— ninja.skulk()，关联在一个对象上，实现面向对象编程 当一个函数被赋值给一个对象的属性，并且通过对象属性引用的方式调用时，函数会作为对象的方法被调用。 当函数作为某个对象的方法被调用时，该对象会成为函数的上下文，并且在函数内部可以访问到。 4.2.3作为一个构造函数（constructor）—— new Ninja()，实例化一个新的对象构造函数和函数构造器区别 构造函数是指new 一个函数的这个函数本身，例如 new Ninja() 函数构造器是通过字符串来狗仔一个新的函数，例如 new Function(‘a’,’b’,’return a+b’) 关键字new调用函数会触发以下动作 创建一个新的空对象 该对象作为this参数传递给构造函数，从而成为构造函数的函数上下文 新构造的对象作为new运算符的返回值 123456789101112function create() { // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 见【构造函数两点特性】 return typeof result === 'object' ? result : obj} 构造函数两点特性 如果构造函数返回一个对象，则该对象将作为整个表达式的值返回，而传入构造函数的this将被丢弃 如果构造函数返回的是非对象类型，则忽略返回值，返回新创建的对象。 4.2.4通过函数的apply或者call方法 调用区别：apply第二个参数数组array ,call 是直接以参数列表的形式传入 Tip: 这里的例子引入了另一个关于addEventListener的知识： addEventListener中的监听函数的this指向调用addEventListener的对象，可以用bind修改 4.3 箭头函数上下文的问题 箭头函数没有单独的this值，箭头函数的this与生命所在的上下文相同。 调用箭头函数时，不会隐式传入this的参数，而是从定义时的函数集成上下文。","link":"/2019/12/29/%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"闭包","slug":"闭包","link":"/tags/%E9%97%AD%E5%8C%85/"},{"name":"函数","slug":"函数","link":"/tags/%E5%87%BD%E6%95%B0/"}],"categories":[{"name":"忍者秘籍","slug":"忍者秘籍","link":"/categories/%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D/"}]}